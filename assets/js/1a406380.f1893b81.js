"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1885],{3905:(e,n,i)=>{i.r(n),i.d(n,{MDXContext:()=>d,MDXProvider:()=>c,mdx:()=>h,useMDXComponents:()=>p,withMDXComponents:()=>m});var o=i(67294);function t(e,n,i){return n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i,e}function a(){return a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var i=arguments[n];for(var o in i)Object.prototype.hasOwnProperty.call(i,o)&&(e[o]=i[o])}return e},a.apply(this,arguments)}function r(e,n){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),i.push.apply(i,o)}return i}function s(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?r(Object(i),!0).forEach((function(n){t(e,n,i[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):r(Object(i)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(i,n))}))}return e}function l(e,n){if(null==e)return{};var i,o,t=function(e,n){if(null==e)return{};var i,o,t={},a=Object.keys(e);for(o=0;o<a.length;o++)i=a[o],n.indexOf(i)>=0||(t[i]=e[i]);return t}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)i=a[o],n.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(t[i]=e[i])}return t}var d=o.createContext({}),m=function(e){return function(n){var i=p(n.components);return o.createElement(e,a({},n,{components:i}))}},p=function(e){var n=o.useContext(d),i=n;return e&&(i="function"==typeof e?e(n):s(s({},n),e)),i},c=function(e){var n=p(e.components);return o.createElement(d.Provider,{value:n},e.children)},f="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},g=o.forwardRef((function(e,n){var i=e.components,t=e.mdxType,a=e.originalType,r=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(i),c=t,f=m["".concat(r,".").concat(c)]||m[c]||u[c]||a;return i?o.createElement(f,s(s({ref:n},d),{},{components:i})):o.createElement(f,s({ref:n},d))}));function h(e,n){var i=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var a=i.length,r=new Array(a);r[0]=g;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[f]="string"==typeof e?e:t,r[1]=s;for(var d=2;d<a;d++)r[d]=i[d];return o.createElement.apply(null,r)}return o.createElement.apply(null,i)}g.displayName="MDXCreateElement"},45053:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var o=i(87462),t=(i(67294),i(3905));const a={},r="[RFC] Configuration Modifiers",s={unversionedId:"rfcs/drafts/cfg-modifiers/api",id:"rfcs/drafts/cfg-modifiers/api",title:"[RFC] Configuration Modifiers",description:"Why do we need new configuration setup?",source:"@site/../docs/rfcs/drafts/cfg-modifiers/api.md",sourceDirName:"rfcs/drafts/cfg-modifiers",slug:"/rfcs/drafts/cfg-modifiers/api",permalink:"/docs/rfcs/drafts/cfg-modifiers/api",draft:!1,tags:[],version:"current",frontMatter:{}},l={},d=[{value:"Why do we need new configuration setup?",id:"why-do-we-need-new-configuration-setup",level:2},{value:"Configuration Background",id:"configuration-background",level:2},{value:"API",id:"api",level:2},{value:"PACKAGE Modifier",id:"package-modifier",level:3},{value:"Target Modifier",id:"target-modifier",level:3},{value:"CLI Modifier",id:"cli-modifier",level:3},{value:"Modifier Resolution",id:"modifier-resolution",level:3},{value:"Modifier-Specific Selects",id:"modifier-specific-selects",level:3},{value:"Legacy Target platform",id:"legacy-target-platform",level:3},{value:"Debugging modifiers",id:"debugging-modifiers",level:2},{value:"How configuration modifiers differ from transitions",id:"how-configuration-modifiers-differ-from-transitions",level:2}],m={toc:d};function p(e){let{components:n,...i}=e;return(0,t.mdx)("wrapper",(0,o.Z)({},m,i,{components:n,mdxType:"MDXLayout"}),(0,t.mdx)("h1",{id:"rfc-configuration-modifiers"},"[RFC]"," Configuration Modifiers"),(0,t.mdx)("h2",{id:"why-do-we-need-new-configuration-setup"},"Why do we need new configuration setup?"),(0,t.mdx)("p",null,"A target usually needs to be built in multiple build settings.\nFor example, there may be different OS (ex. linux, mac, windows),\narchitectures (ex. x86, arm), and sanitizers\n(ex. asan, tsan, ubsan) to use for a single target. Buck has 2 main ways of supporting customizations today:"),(0,t.mdx)("ol",null,(0,t.mdx)("li",{parentName:"ol"},"Buckconfigs specified through ",(0,t.mdx)("inlineCode",{parentName:"li"},"--config")," or ",(0,t.mdx)("inlineCode",{parentName:"li"},"-c")," flags. They are global flags and are often aggregated in modefiles (",(0,t.mdx)("inlineCode",{parentName:"li"},"@<modefile>")," on the command line)."),(0,t.mdx)("li",{parentName:"ol"},"Target platforms specified through ",(0,t.mdx)("inlineCode",{parentName:"li"},"default_target_platform")," attribute or ",(0,t.mdx)("inlineCode",{parentName:"li"},"--target-platforms"),' flag), which become a target\'s "configuration". ',(0,t.mdx)("inlineCode",{parentName:"li"},"--target-platforms")," flags are also commonly specified via modefiles.")),(0,t.mdx)("p",null,"These methods are problematic for the following reasons."),(0,t.mdx)("ol",null,(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("em",{parentName:"p"},"We have too many modefiles"),". A project that needs customizations often ends\nup adding its own set of modefiles, causing a continued rise in number of\ncustom modefiles in the repo. Internally, the number of modefiles in our\nmonorepo is currently on the order of ",(0,t.mdx)("strong",{parentName:"p"},"10,000s"),".")),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("em",{parentName:"p"},"Changing buckconfigs invalidates Buck's state"),". Changing buckconfigs or\nmodefiles of buckconfigs invalidates global state, which adds non-trivial Buck\noverhead on every incremental build that changes state. This does not affect\ntarget platforms.")),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("em",{parentName:"p"},"Different modefiles of buckconfigs cannot be used in same build"),".\nUsers that need to run multi-configuration builds today often work around this\nby writing scripts that wraps multiple buck build invocations of different\nmodes. This is slow because Buck state keeps getting repeatedly invalidated.\nThere is also no way to build a target in different modes (ex. dev and opt) at\nthe same time, so users that need to do this always have to do this\nsequentially. This does not affect target platforms.")),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("em",{parentName:"p"},"Target platform generation is exponential in number of build settings"),".\nSuppose I want to customize targets based on 3 OSes, 2 architectures, and 3\ncompilers. With target platforms, I need to first generate all 18 permutations\nof these settings as platform targets before using them. This is not scalable.")),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("em",{parentName:"p"},"Target platform does not compose well on command line"),". Suppose I want to\nuse ASAN on top of some existing platform. It's not possible to say specify\nASAN on top of an existing platform on the command line. Instead, I must create\na new platform target with ASAN added to the existing platform before I can use\nit.")),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("em",{parentName:"p"},"Poor user Experience"),". When every project needs its own set of modes, it's\nonerous for users to track what modes are needed to build what targets. Users\noften don't realize when they are using the wrong or unnecessary command line\nflags.")),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("em",{parentName:"p"},"Poor tooling integration"),". Similar to user, it's just onerous for tooling\nto keep track of what modes are needed to build a target with. Buckconfigs are\nalso bad for performance for tools like language servers because it's impossible\nto request the builds of two modes in parallel when two targets needs different\nmodes.")),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("em",{parentName:"p"},"Antithetical to Buck's principles"),". Buck's main strength is the ability to abstract away builds of different languages and libraries under one common syntax for the user. The need for project-custom flags goes against this principle."))),(0,t.mdx)("p",null,"The Modifier API introduces a unified way to specify build settings on a\nproject, target, and command line level. Like target platforms, it constructs Buck configurations so it supports multi-configuration builds. It\navoids modefile proliferation by allowing users to easily\nset project-specific build settings like compiler and toolchain versions in\nthe repo rather than on the command line. It avoids scalability problems of\nplatform generation by being composition-first. The goals of this project is to:"),(0,t.mdx)("ol",null,(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("em",{parentName:"li"},"Make ",(0,t.mdx)("inlineCode",{parentName:"em"},"buck build")," work on any platform without the use of special flags"),".\nToday, building a mac target on mac often requires a mac mode,\nand likewise for windows. Instead, ",(0,t.mdx)("inlineCode",{parentName:"li"},"buck build")," should always work\nout of the box on any platform so that there's no need to specify mac mode on\nmacs or windows mode on windows."),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("em",{parentName:"li"},"Define a small constrained set of common modifiers that can be used to build any target\nin the repo"),". This will include common options like mode (ex. dev, opt, release), OS (ex. linux, mac, iphoneos), and architecture (ex. x86, arm)."),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("em",{parentName:"li"},"Unblock cross-building for the majority of targets"),". ",(0,t.mdx)("inlineCode",{parentName:"li"},"host_info()"),' is\na hack to obtain information about the host machine that is the main blocker to\nBuck2 cross-building (ex. building a mac or windows\ntarget from linux) working everywhere. As an extension of "making ',(0,t.mdx)("inlineCode",{parentName:"li"},"buck build"),'\nwork on any platform", modifiers should make it possible to kill off most use cases of ',(0,t.mdx)("inlineCode",{parentName:"li"},"host_info")," in the repo."),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("em",{parentName:"li"},"Simplify building build tooling"),". Because ",(0,t.mdx)("inlineCode",{parentName:"li"},"buck build")," works out of\nthe box, tools like language servers can build targets they need without using\nproject-specific modefiles or flags."),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("em",{parentName:"li"},"Delete most modefiles from the repo"),"."),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("em",{parentName:"li"},"Deprecate target platforms for modifiers as the sole way of configuring top-level\ntargets in Buck"),".")),(0,t.mdx)("h2",{id:"configuration-background"},"Configuration Background"),(0,t.mdx)("p",null,(0,t.mdx)("em",{parentName:"p"},"Feel free to skip this if you already understand Buck configurations.")),(0,t.mdx)("p",null,"A configuration is a collection of ",(0,t.mdx)("inlineCode",{parentName:"p"},"constraint_value")," targets\n(commonly referred to as constraints).\nIt defines the build settings used by a target.\nA constraint value is keyed by a ",(0,t.mdx)("inlineCode",{parentName:"p"},"constraint_setting"),", so there can only\nbe one ",(0,t.mdx)("inlineCode",{parentName:"p"},"constraint_value")," of a ",(0,t.mdx)("inlineCode",{parentName:"p"},"constraint_setting")," in a configuration."),(0,t.mdx)("p",null,"For example, suppose ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:_")," is a constraint setting with constraint\nvalues ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:linux"),", ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:macos"),", and ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:windows"),". Then\na configuration may contain either ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:linux"),", ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:macos"),",\nor ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:windows")," to indicate which OS a target is built for."),(0,t.mdx)("p",null,"A constraint or a set of constraints can be selected on via ",(0,t.mdx)("inlineCode",{parentName:"p"},"select()")," to\ncustomize a target's behavior. For example, the following adds a linux only\ndep to a target."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-python"},'deps = select({\n   "cfg//os:linux": [":linux_only_dep"],\n   "DEFAULT": [],\n})\n')),(0,t.mdx)("p",null,"Before building a target on the command line (known as the top-level target),\nBuck needs to know its configuration in order to resolve selects. Modifiers\nare a new way to resolve a target's configuration for every top-level target."),(0,t.mdx)("h2",{id:"api"},"API"),(0,t.mdx)("p",null,'Every top-level target starts with an empty configuration, and Buck will apply\na list of "modifiers" to obtain a configuration. A modifier is a modification\nof a constraint from the existing configuration to obtain a new\nconfiguration.'),(0,t.mdx)("p",null,"The simplest modifier is a constraint value, which inserts\nthat value into the configuration for its respective constraint setting,\nreplacing any existing constraint value for that setting.\nFor example, specifying ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:linux")," as a modifier will\ninsert ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:linux")," into the configuration,\noverriding any existing constraint value for the\n",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:_")," constraint setting."),(0,t.mdx)("p",null,"Another type of modifier is a ",(0,t.mdx)("inlineCode",{parentName:"p"},"modifier_select()")," of a constraint value.\nThis can change the constraint value inserted based on the existing\nconfiguration. For example, a modifier like"),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-python"},'modifier_select({\n  "cfg//os:windows": "cfg//compiler:msvc",\n  "DEFAULT": "cfg//compiler:clang",\n})\n')),(0,t.mdx)("p",null,"will insert msvc constraint into the configuration if OS is windows or clang\nconstraint otherwise.\nA ",(0,t.mdx)("inlineCode",{parentName:"p"},"modifier_select()")," behaves similarly to Buck's ",(0,t.mdx)("inlineCode",{parentName:"p"},"select()")," but can only\nbe used in a modifier.\nA ",(0,t.mdx)("inlineCode",{parentName:"p"},"modifier_select()")," can only be used to modify a single constraint setting,\nso the following example is not valid."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-python"},'# This fails because a modifier cannot modify both compiler and OS.\nmodifier_select({\n  "cfg//os:windows": "cfg//compiler:msvc",\n  "DEFAULT": "cfg//os:linux",\n})\n')),(0,t.mdx)("p",null,"A modifier can be specified in a PACKAGE file, on a target, or on the command\nline. This provides the flexibility needed to customize targets on a project,\ntarget, or cli level."),(0,t.mdx)("h3",{id:"package-modifier"},"PACKAGE Modifier"),(0,t.mdx)("p",null,"In a PACKAGE file, modifiers can be specified using the ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg_modifiers"),"\nfunction and would apply to all targets covered under that PACKAGE. For\nexample, modifiers specified in ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo/PACKAGE")," would apply to any target under\n",(0,t.mdx)("inlineCode",{parentName:"p"},"repo//..."),". Modifiers specified in ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo/foo/PACKAGE")," would apply to any target under ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo//foo/..."),' (For resolution order, see "Modifier\nResolution" section).'),(0,t.mdx)("p",null,"The ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg_modifiers")," function takes as input\na dictionary of constraint setting to modifier for that setting.\nFor example, the following is an example that sets modifiers for OS and compiler settings in the repo's top PACKAGE file for all targets in repo."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-python"},'# repo/PACKAGE\n\ncfg_modifiers({\n  "cfg//os:_": "cfg//:linux",\n  "cfg//compiler:_": modifier_select({\n    "DEFAULT": "cfg//compiler:clang",\n    "cfg//os:windows": "cfg//compiler:msvc",\n  })\n})\n')),(0,t.mdx)("p",null,"To make constraints easier to type, you can specify aliases for modifier targets\nvia Buck's target aliases."),(0,t.mdx)("p",null,"For example, suppose the following aliases exist in ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo/.buckconfig"),"."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-ini"},"[alias]\n  os = cfg//os:_\n  linux = cfg//os:linux\n  macos = cfg//os:macos\n  windows = cfg//os:windows\n  compiler = cfg//compiler:_\n  clang = cfg//compiler:clang\n  msvc = cfg//compiler:msvc\n")),(0,t.mdx)("p",null,"Then the same PACKAGE modifiers can be specified as follows."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-python"},'# repo/PACKAGE\n\ncfg_modifiers({\n  "os": "linux",\n  "compiler": modifier_select({\n    "DEFAULT": "clang",\n    "windows": "msvc",\n  })\n})\n')),(0,t.mdx)("h3",{id:"target-modifier"},"Target Modifier"),(0,t.mdx)("p",null,"On a target, modifiers can be specified on the ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg_modifiers")," attribute.\nFor example, the following specifies modifiers for ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo//foo:bar"),"."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-python"},'# repo/foo/BUCK\n\npython_binary(\n  name = "bar",\n  # ...\n  cfg_modifiers = {\n    "cfg//os:_": "cfg//os:windows",\n    # Target modifiers can also use aliases\n    "compiler": "clang",\n  },\n)\n')),(0,t.mdx)("h3",{id:"cli-modifier"},"CLI Modifier"),(0,t.mdx)("p",null,"On the command line, modifiers are specified as\n",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build <target>?<modifiers separated by commas>"),"."),(0,t.mdx)("p",null,"For example,\n",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar?cfg//sanitizer:asan")," applies asan\nmodifier on the command line.\n",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar?cfg//os:linux,cfg//sanitizer:asan"),"\nwill apply linux and asan modifiers.\nAliases can also be used on command line, so\n",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar?asan")," is valid."),(0,t.mdx)("p",null,"Command line modifiers cannot be selects, although this may\nbe revisited if necessary."),(0,t.mdx)("p",null,"Modifiers can be specified for any target pattern, so\n",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo/...?asan")," and\n",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:?asan")," are also valid.\nWhen specifying a subtarget and modifier with ",(0,t.mdx)("inlineCode",{parentName:"p"},"?"),",\nsubtarget should go before modifier,\nex. ",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar[comp-db]?asan"),"."),(0,t.mdx)("p",null,"To specify modifiers to a list of target patterns on the command line,\nyou can use the ",(0,t.mdx)("inlineCode",{parentName:"p"},"--modifier")," or ",(0,t.mdx)("inlineCode",{parentName:"p"},"-m")," flag.\nFor example, ",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar repo//foo:baz -m release"),"\nis equivalent to ",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar?release //foo:baz?release"),"."),(0,t.mdx)("p",null,(0,t.mdx)("inlineCode",{parentName:"p"},"--modifier")," flag can be specified multiple times to add multiple modifier, so\n",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build --modifier=linux --modifier=release repo//foo:bar"),"\nis equivalent to ",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar?linux,release"),"."),(0,t.mdx)("p",null,"It is prohibited to specify both ",(0,t.mdx)("inlineCode",{parentName:"p"},"--modifier")," flag and ",(0,t.mdx)("inlineCode",{parentName:"p"},"?")," in target pattern.\nThis restriction can be lifted in the future if there is a need."),(0,t.mdx)("p",null,"When two modifiers of the same constraint setting are specified, then the later one overrides the earlier one. For example,\n",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar?dev,release")," is equivalent to\n",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 build repo//foo:bar?release"),"."),(0,t.mdx)("p",null,"On command line, a ",(0,t.mdx)("inlineCode",{parentName:"p"},"config_setting")," target can be specified as a collection of\nmodifiers after ",(0,t.mdx)("inlineCode",{parentName:"p"},"--modifier")," or ",(0,t.mdx)("inlineCode",{parentName:"p"},"?"),". This will be equivalent to specifying each\nconstraint inside the ",(0,t.mdx)("inlineCode",{parentName:"p"},"config_setting")," as a separate modifier."),(0,t.mdx)("h3",{id:"modifier-resolution"},"Modifier Resolution"),(0,t.mdx)("p",null,"Modifiers are resolved in order of constraint setting, and for each constraint\nsetting, modifiers for that setting are resolved in order of PACKAGE, target,\nand command line, with modifier from parent PACKAGE applied before child\nPACKAGE. The end of this section will describe how Buck determines the order\nof constraint setting to resolve."),(0,t.mdx)("p",null,"Suppose modifiers for ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo//foo:bar")," are specified as follows."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-python"},'# repo/PACKAGE\n\ncfg_modifiers({\n  "cfg//os:_": "cfg//:linux",\n  "cfg//compiler:_": modifier_select({\n    "DEFAULT": "cfg//compiler:clang",\n    "cfg//os:windows": "cfg//compiler:msvc",\n  })\n})\n\n# repo/foo/PACKAGE\n\ncfg_modifiers({\n  "cfg//os:_": "cfg//os:macos",\n})\n\n# repo/foo/BUCK\n\npython_binary(\n  name = "bar",\n  # ...\n  cfg_modifiers = {\n    "cfg//os:_": "cfg//os:windows",\n  },\n)\n')),(0,t.mdx)("p",null,"At the beginning, the configuration will be empty.\nWhen resolving modifiers, Buck will first resolve all modifiers for\n",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:_")," before resolving all modifiers for ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//compiler:_"),"."),(0,t.mdx)("p",null,"For OS, the linux modifier from ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo/PACKAGE")," will apply first, followed by\nmacos modifier from ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo/foo/PACKAGE")," and windows modifier from\n",(0,t.mdx)("inlineCode",{parentName:"p"},"repo//foo:bar"),"'s target modifiers, so ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo//foo:bar")," will end up with\n",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:windows")," for ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//os:_")," in its configuration. Next, to resolve\ncompiler modifier, the ",(0,t.mdx)("inlineCode",{parentName:"p"},"modifier_select")," from ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo/PACKAGE")," will resolve to\n",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//compiler:msvc")," since existing configuration is windows and apply that as\nthe modifier. The target configuration for ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo//foo:bar")," ends up with windows\nand msvc."),(0,t.mdx)("p",null,"However, suppose user invokes ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo//foo:bar?linux")," on the command line. When\nresolving OS modifier, the linux modifier from cli will override any existing\nOS constraint and insert linux into the configuraiton. Then, when resolving the\ncompiler modifier, the ",(0,t.mdx)("inlineCode",{parentName:"p"},"modifier_select")," will resolve to ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//compiler:clang"),",\ngiving clang and linux as the final configuration."),(0,t.mdx)("p",null,"Because command line modifiers will apply at the end, they\nare also known as required modifiers. Any modifier specified on the command line\nwill always override any modifier for the same constraint setting specified in\nthe repo."),(0,t.mdx)("p",null,"The ordering of constraint setting to resolve modifiers is determined based on\ndependency order of constraints specified in the keys of the ",(0,t.mdx)("inlineCode",{parentName:"p"},"modifier_select"),"\nspecified. Because some modifiers select on other constraints, modifiers for\nthose constraints must be resolved first. In the previous example, because\ncompiler modifier selects on OS constraints, Buck will resolve all\nOS modifiers before resolving compiler modifiers.\n",(0,t.mdx)("inlineCode",{parentName:"p"},"modifier_select")," that ends up with a cycle of selected constraints\n(ex. compiler modifier selects on sanitizer but sanitizer modifier also selects\non compiler) will be an error."),(0,t.mdx)("h3",{id:"modifier-specific-selects"},"Modifier-Specific Selects"),(0,t.mdx)("p",null,"Modifiers have 3 types of select operators that allow for powerful compositions.\nEach operation is a function that accepts a dictionary where the keys are\nconditionals and values are modifiers."),(0,t.mdx)("ol",null,(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("inlineCode",{parentName:"p"},"modifier_select"),". Introduced in the previous sections, this is capable of\ninserting constraints based on constraints in the existing configuration.")),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("inlineCode",{parentName:"p"},"rule_select"),'. This is capable of selecting based on the rule name (also\nknown as rule type). The keys are regex patterns to match against the rule\nname or "DEFAULT". Partial matches are allowed.')),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("inlineCode",{parentName:"p"},"host_select"),". This selects based on the host configuration,\nwhereas ",(0,t.mdx)("inlineCode",{parentName:"p"},"modifier_select")," selects based on the target configuration. This\nhost configuration is constructed when resolving modifiers. ",(0,t.mdx)("inlineCode",{parentName:"p"},"host_select")," is\nimportant to making ",(0,t.mdx)("inlineCode",{parentName:"p"},"buck build")," work anywhere on any platform. For example,\nwhen the OS to configure is not specified, it's best to assume that the user\nwants to target the same OS as the host machine."))),(0,t.mdx)("p",null,"An example using ",(0,t.mdx)("inlineCode",{parentName:"p"},"rule_select")," and ",(0,t.mdx)("inlineCode",{parentName:"p"},"host_select")," is as follows."),(0,t.mdx)("pre",null,(0,t.mdx)("code",{parentName:"pre",className:"language-python"},'# root/PACKAGE\n\n# We want OS to target the host machine by default.\n# Ex. build linux on linux machine, build windows on windows machine,\n# and build mac on mac machine.\n# However, if the rule is apple or android specific, then we should\n# always be building for apple/android as OS, no matter the host\n# configuration.\n\ncfg_modifiers({\n  "cfg//os:_": rule_select({\n    "apple_.*": "cfg//os:iphone",\n    "android_.*": "cfg//os:android",\n    "DEFAULT": host_select({\n      "cfg//os:linux": "cfg//os:linux",\n      "cfg//os:macos": "cfg//os:macos",\n      "cfg//os:windows": "cfg//os:windows",\n    })\n  })\n})\n')),(0,t.mdx)("p",null,"On select resolution, Buck's ",(0,t.mdx)("inlineCode",{parentName:"p"},"select"),' currently requires unambiguous\nkeys in the dictionary and resolves to the key with the most refined match.\nThe select operators used in modifiers will diverge from this and implement\na "first-match" behavior, where select resolves to the first condition that evalutes to true in the dictionary.'),(0,t.mdx)("h3",{id:"legacy-target-platform"},"Legacy Target platform"),(0,t.mdx)("p",null,"Target platform (",(0,t.mdx)("inlineCode",{parentName:"p"},"--target-platforms")," flag or ",(0,t.mdx)("inlineCode",{parentName:"p"},"default_target_platform"),"\nattribute) will be a deprecated way of specifying configuration and will be\nkilled once all use cases migrate to modifiers. To maintain backwards compatibility\nwith target platforms during the migration process, modifier resolution\nwill take into account the target platform specified. This allows for an easy\nmigration where modifiers can be introduced one at a time without reaching\nfeature parity of target platform."),(0,t.mdx)("p",null,"If a target's modifiers resolve to an empty configuration, then Buck will reuse\nthe target platform as the configuration. If modifiers resolve to a non-empty\nconfiguration, then Buck look for any constraint in the target platform not\ncovered by a constraint setting from the modifier configuration and add those\nto the configuration.\nFor example, suppose in the previous example, the target platform for ",(0,t.mdx)("inlineCode",{parentName:"p"},"repo//\nfoo:bar")," includes ",(0,t.mdx)("inlineCode",{parentName:"p"},"cfg//sanitizer:asan"),", then this constraint will be inserted\ninto the configuration since no modifier covered the sanitizer constraint\nsetting."),(0,t.mdx)("h2",{id:"debugging-modifiers"},"Debugging modifiers"),(0,t.mdx)("p",null,"Because many layers of modifiers can be applied before obtaining\na final configuration, it is important that modifier resolution is easy\nto debug and understand. Here are some ways that modifier resolution\ncan be interpreted."),(0,t.mdx)("ol",null,(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("em",{parentName:"p"},(0,t.mdx)("inlineCode",{parentName:"em"},"buck2 audit modifiers")," command"),". There will be a ",(0,t.mdx)("inlineCode",{parentName:"p"},"buck2 audit modifiers"),"\ncommand to show all PACKAGE, target, and required modifiers for a target. It\ncan also show configuration changes from modifier resolution process if\nrequested by the user.")),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("p",{parentName:"li"},(0,t.mdx)("em",{parentName:"p"},"Starlark print statements or debugger"),".\nModifier resolution process will be implemented in Starlark in prelude.\nThis means that any user can use any of the existing way to debug starlark\n(ex. print statements, Starlark debugger in VSCode) to debug the resolution\nprocess."))),(0,t.mdx)("h2",{id:"how-configuration-modifiers-differ-from-transitions"},"How configuration modifiers differ from transitions"),(0,t.mdx)("p",null,"Modifiers are largely inspired by configuration transitions.\nThe difference between modifier and transition is that a transition can change\nthe configuration of any target in the graph, but a modifier can only change\nthe configuration of a top-level target. In other words, if you have target A\nthat depends on target B and you request a build of A, then A's target\nconfiguration would be resolved via modifiers and propagated down to B, but dep\nB would not do its own modifier resolution. When a top-level target goes through\na per-rule transition, that transition is applied after modifiers are resolved."),(0,t.mdx)("p",null,"Below are some examples that show when to use modifier and when to use\ntransition."),(0,t.mdx)("ol",null,(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("em",{parentName:"li"},"Python version")," should be modeled as a transition and not modifier.\nSuppose we have ",(0,t.mdx)("inlineCode",{parentName:"li"},"python_binary")," A nested as a resource of\nanother ",(0,t.mdx)("inlineCode",{parentName:"li"},"python_binary")," B. A should not inherit the python version\nfrom B, so a transition is needed to change A's python version\nwhen depended on by B."),(0,t.mdx)("li",{parentName:"ol"},(0,t.mdx)("em",{parentName:"li"},"Library target")," should use modifiers and not transitions.\nA C++ library target should always inherit the configuration\nof its parent C++ binary when it is used as a dep,\nbut a top-level C++ library target can still have its configuration\nchanged via modifiers when requested from command line.")),(0,t.mdx)("p",null,"In the future, we may add support for modifier transition, which can\ntransition via modifiers, but that is out of the scope of this RFC."))}p.isMDXComponent=!0}}]);